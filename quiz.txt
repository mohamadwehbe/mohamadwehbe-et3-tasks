I. Array :
1. var array = new Array("apples", "oranges"); or var array = ["apples","oranges"];
2. array.map() : Generally map() method is used to iterate over an array and calling function on every element of array.
                 It returns a new array and elements of arrays are result of callback function.
    array.map(row=>{
        row = row * 3.5 ;
    })
3. array.filter() : The filter() method creates an array filled with all array elements that pass a test (provided by a function).
                        filter() does not execute the function for empty array elements.
                        filter() does not change the original array.
                    returns a value that coerces(gives) to true.
    intern = array.filter(row=>row.status === "intern");
    internMore23 = array.filter(row=> row.status === "intern" && row.age > 23);
4. array.reduce() :  reduce the array to a single value and executes a provided function for each value of the array (from left-to-right).
                     returns a single value which is the function's accumulated result
                     reduce() does not execute the function for empty array elements.
    array.reduce(function(accumulator, currentValue) {
    return accumulator + currentValue.age;
    }, 0);

II. Promises :
1.  Synchronous code is executed in sequence – each statement waits for the previous statement to finish before executing.
    Asynchronous code doesn't have to wait – your program can continue to run.
    You do this to keep your site or app responsive, reducing waiting time for the user.

2.  A promise is an object that may produce a single value some time in the future :
    either a resolved value, or a reason that it's not resolved (e.g., a network error occurred).
    A promise may be in one of 3 possible states: fulfilled, rejected, or pending.

3. Promise.resolve('Success').then((value)=> {
   console.log(value); // "Success"
   }, (value)=> {
   // not called
   });

4. function resolved(result) {
    console.log('Resolved');
   }
   function rejected(result) {
    console.error(result);
   }
   Promise.reject(new Error('fail')).then(resolved, rejected);
   // expected output: Error: fail

5. In my view, unless a library or legacy codebase forces you to use then/catch,
   the better choice for readability and maintainability is async/await.
   for some more info, even if a library does make you use it,
   you can create a promise and return it as async/await

6. The Promise.all() method takes an iterable of promises as an input,
   and returns a single Promise that resolves to an array of the results of the input promises.
   This returned promise will resolve when all of the input's promises have resolved,
   or if the input iterable contains no promises.
   It rejects immediately upon any of the input promises rejecting or non-promises throwing an error,
   and will reject with this first rejection message / error.

7. The Promise.race() method returns a promise that fulfills or rejects as soon as one of the promises
   in an iterable fulfills or rejects, with the value or reason from that promise.

8. Promice.all() accepts an array of promises, and will attempt to fulfill all of them. Exits early if just 1 promise gets rejected.
   Promise.race() also accepts an array of promises, but returns the first promise that is settled.
   So it depends of what we need from those options.

9. setTimeout is synchronous in nature and it runs synchronously and queues a function to run later.

10. How callback function works: We will pass a function into a timeout as an argument,
    and our function will be executed after the timeout is executed.
    A callback is a function passed into another function as an argument to be executed later.

III. Lodash :

1. max = 0 ;
   _.map(employees, emp => {
     if(emp.age > max) max = emp.age;
   });
   // max is the highest age
   OR: let max_age = _.maxBy(employees, emp=>emp.age);

2. let descending = _.orderBy(employees, ['age'], ['desc']);

3. let ascending = _.orderBy(employees, ['age'], ['asc']);

4. employee = _.filter(employees, emp=>emp.name === 'Anthony');
   age = _.get(employee,'age');

5. Getting the name of the developer : developer = _.filter(employees, emp=>emp.status === 'Developer');
   Snake case the string : _.snakeCase(developer); // developer is a string = 'Hovig'